---
title: "On Using and Extending the `MsBackendRawFileReader` Backend"
author:
- name: Tobias Kockmann
  affiliation:
    - &id Functional Genomics Center Zurich - Swiss Federal Institute of Technology in Zurich
  email: Tobias.Kockmann@fgcz.ethz.ch
- name: Christian Panse
  affiliation:
    - *id
    - Swiss Institute of Bioinformatics
  email: cp@fgcz.ethz.ch
ppackage: MsBackendRawFileReader
output:
  BiocStyle::html_document:
    toc_float: true
abstract: |
  `r BiocStyle::Githubpkg("fgcz/MsBackendRawFileReader")` implements an
  MsBackend for the `r BiocStyle::Biocpkg("Spectra")` package using
  Thermo Fisher Scientific's NewRawFileReader .Net libraries.
  The package is generalizing the functionallity provided by the
  `r BiocStyle::Biocpkg("rawrr")`. The vignette utilizes data provided through
  the `r BiocStyle::Biocpkg("tartare")` package. 
vignette: |
  %\VignetteIndexEntry{On Using and Extending the `MsBackendRawFileReader` Backend.}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography:
  - MsBackendRawFileReader.bib
---

# Requirements

```{r require}
suppressMessages(
  stopifnot(require(Spectra),
            require(MsBackendRawFileReader),
            require(tartare),
            require(BiocParallel))
)
```

assemblies aka Common Intermediate Language bytecode 
The download and install can be done on all platforms using the command:
`rawrr::installRawFileReaderDLLs()`


```{r installAssemblies, echo=TRUE}
if (isFALSE(rawrr::.checkDllInMonoPath())){
  rawrr::installRawFileReaderDLLs()
}

if (isFALSE(file.exists(rawrr:::.rawrrAssembly()))){
 rawrr::installRawrrExe(sourceUrl = "http://fgcz-ms.uzh.ch/~cpanse/rawrr/rawrr.1.1.12.exe")
}
```


# Load data

```{r tartareEH4547, warning=FALSE, message=FALSE, eval=TRUE}
# fetch via ExperimentHub
library(ExperimentHub)
eh <- ExperimentHub::ExperimentHub()
```

```{r tartare}
query(eh, c('tartare'))
```

The RawFileReader libraries require a file extension ending with `.raw`.

```{r EH3220, message=FALSE, warning=FALSE}
EH3220 <- normalizePath(eh[["EH3220"]])
(rawfileEH3220 <- paste0(EH3220, ".raw"))
if (!file.exists(rawfileEH3220)){
  file.link(EH3220, rawfileEH3220)
}

EH3222 <- normalizePath(eh[["EH3222"]])
(rawfileEH3222 <- paste0(EH3222, ".raw"))
if (!file.exists(rawfileEH3222)){
  file.link(EH3222, rawfileEH3222)
}

EH4547  <- normalizePath(eh[["EH4547"]])
(rawfileEH4547  <- paste0(EH4547 , ".raw"))
if (!file.exists(rawfileEH4547 )){
  file.link(EH4547 , rawfileEH4547 )
}
```

# Usage

Call the constructor

```{r backendInitialize, message=FALSE}
beRaw <- Spectra::backendInitialize(
  MsBackendRawFileReader::MsBackendRawFileReader(),
  files = c(rawfileEH3220, rawfileEH3222, rawfileEH4547))
```

Call the print method

```{r show}
beRaw
```

# Application example

Here we reproduce the Figure 2 of @rawrr `r BiocStyle::Biocpkg("rawrr")`.
The `r BiocStyle::Githubpkg("fgcz/MsBackendRawFileReader")` ships with a 
`filterScan` method  using functionality provided by the C# libraries by 
Thermo Fisher Scientific @rawfilereader.

```{r rawrrFigure2, fig.retina=3, fig.cap = "Peptide spectrum match. The vertical grey lines indicate the *in-silico* computed y-ions of the peptide precusor LGGNEQVTR++ as calculated by the [protViz]( https://CRAN.R-project.org/package=protViz) package [@protViz]."}
(S <- (beRaw |>  
   filterScan("FTMS + c NSI Full ms2 487.2567@hcd27.00 [100.0000-1015.0000]") )[437]) |> 
  plotSpectra()

# supposed to be scanIndex 9594
S

# add yIonSeries to the plot
(yIonSeries <- protViz::fragmentIon("LGGNEQVTR")[[1]]$y[1:8])
names(yIonSeries) <- paste0("y", seq(1, length(yIonSeries)))
abline(v = yIonSeries, col='#DDDDDD88', lwd=5)
axis(3, yIonSeries, names(yIonSeries))
```

# Extend the class

For demonstration reasons, we extent the `MsBackend` class by a filter method.
The `filterIons` function returns spectra if and only if all fragment ions,
given as argument, match. We use `r BiocStyle::CRANpkg("protViz")``::findNN`
binary search
method for determining the nearest mZ peak for each ion.
If the mass error between an ion and an mz value is less than the given mass
tolerance, an ion is considered a hit.
 
```{r defineFilterIon}
setGeneric("filterIons", function(object, ...) standardGeneric("filterIons"))

setMethod("filterIons", "MsBackend",
  function(object, mZ=numeric(), tol=numeric(), ...) {
    
    keep <- lapply(peaksData(object, BPPARAM = bpparam()),
                   FUN=function(x){
       NN <- protViz::findNN(mZ, x[, 1])
       hit <- (error <- mZ - x[NN, 1]) < tol & x[NN, 2] >= quantile(x[, 2], .9)
       #print(hit)
       if (sum(hit) == length(mZ))
         TRUE
       else
         FALSE
                   })
    
    object[unlist(keep)]
  })
```

The code snippet below applies the defined `filterIons` method and finds two spectra.
Both spectra are combined into one singe spectrum. The output ist shown below.

```{r filterIons2, fig.retina=3, fig.cap = "Combined peptide spectrum plot. "}
beRaw |> 
  filterScan("FTMS + c NSI Full ms2 487.2567@hcd27.00 [100.0000-1015.0000]") |>
  filterIons(yIonSeries, tol = 0.005) |> 
  Spectra() |>
  peaksData() |>
  combinePeaks(ppm=10) |>
  plot(type='h')

abline(v = yIonSeries, col='#DDDDDD88', lwd=5)
axis(3, yIonSeries, names(yIonSeries))
```

# Evaluation

## I/O Benchmark

When reading spectra the
`MsBackendRawFileReader:::.RawFileReader_read_peaks`
method is calling the 
`rawrr::readSpectrum`
method.

The figure below displays the time performance in dependency from the chunk size (how many spectra are read in one function call) for different.

```{r readBenchmarkData, fig.retina=3, fig.cap="I/O Benchmark. The XY plot graphs the time versus the chunk size of the rawrr::readSpectrum method for different compute architectures."}

specs.readSpectra <- file.path(system.file(package = 'MsBackendRawFileReader'),
               'extdata', 'specs.csv') |>
  read.csv2(header=TRUE)

lattice::xyplot((as.numeric(time)) * workers ~ size | factor(n) ,
                group= host,
                data=specs.readSpectra,
                horizontal=FALSE,
                auto.key = TRUE,
                layout=c(3,1),
                ylab='time [seconds] to read a spectrum',
                xlab='number of spectra / file')
```

# Session information

```{r si}
sessionInfo()
```

# References
